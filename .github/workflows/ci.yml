name: CI

on:
  pull_request:
  push:
    branches: [ main, master ]
    # Add replicant branches if they exist:
    # branches: [ main, master, claude/RepositoryName_Replicants ]

# Minimal permissions for security
permissions:
  contents: read

jobs:
  lint-and-test:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    strategy:
      fail-fast: true  # ‚úÖ Always include
    
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for better diffs
          
      - uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          
      - name: Cache pip
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          # ‚úÖ Comprehensive cache key pattern
          key: ${{ runner.os }}-pip-${{ hashFiles('**/*requirements*.txt', '**/pyproject.toml', '**/setup.py', '**/setup.cfg') }}
          restore-keys: |
            ${{ runner.os }}-pip-
            
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          # Install from python/ subdirectory
          if [ -f python/requirements.txt ]; then pip install -r python/requirements.txt; fi
          if [ -f pyproject.toml ]; then pip install -e .; fi
          # ‚úÖ Pin tool versions
          pip install ruff==0.5.0 black==24.4.2 pytest==8.3.3 pytest-cov==6.0.0 pre-commit==3.7.0
          # Upgrade mypy to latest to avoid internal error bugs
          pip install --upgrade mypy
          
      - name: Run MATLAB Quality Check (Static Analysis)
        id: matlab-quality
        continue-on-error: true  # Non-blocking due to MATLAB license restrictions
        run: |
          if [ -f tools/matlab_utilities/scripts/matlab_quality_check.py ]; then
            echo "=========================================="
            echo "MATLAB Code Quality Checks"
            echo "=========================================="
            python tools/matlab_utilities/scripts/matlab_quality_check.py --output-format json > matlab_quality_results.json || true
            python tools/matlab_utilities/scripts/matlab_quality_check.py --output-format text || echo "‚ö†Ô∏è  Quality issues found - see report above (non-blocking)"
          else
            echo "‚ÑπÔ∏è  No MATLAB quality check script found - skipping"
          fi
          
      - name: Upload MATLAB Quality Report
        if: always() && steps.matlab_quality.outcome != 'skipped'
        uses: actions/upload-artifact@v4
        with:
          name: matlab-quality-report
          path: matlab_quality_results.json
          retention-days: 30
          if-no-files-found: ignore
          
      - name: Run quality check
        id: quality-check
        run: |
          echo "üîç Checking for placeholders and magic numbers..."
          # ‚úÖ Check both possible script locations
          if [ -f scripts/quality-check.py ]; then
            python scripts/quality-check.py
          elif [ -f scripts/quality_check.py ]; then
            python scripts/quality_check.py
          elif [ -f quality_check_script.py ]; then
            python quality_check_script.py
          else
            echo "‚ö†Ô∏è No quality check script found, skipping..."
          fi
          
      - name: Check for placeholders
        id: placeholders
        run: |
          # Fail if TODO, FIXME, or other placeholders found in Python files
          # Exclude quality check scripts that contain the patterns they check for
          # Note: Ellipsis (...) is handled by quality_check_script.py to avoid false positives
          # with string literals like '...' or "..."
          # Note: pass statement detection looks for explicit placeholder keywords (TODO/FIXME/XXX/HACK)
          # in comments. Standalone pass statements are handled by quality_check_script.py
          # The pattern uses [[:space:]]* to handle variable whitespace between 'pass', '#', and keywords
          if grep -rE "TODO|FIXME|XXX|HACK|pass[[:space:]]*#[[:space:]]*(TODO|FIXME|XXX|HACK)|NotImplementedError" \
            --include="*.py" \
            --exclude-dir=".git" \
            --exclude-dir="archive" \
            --exclude-dir="legacy" \
            --exclude-dir="experimental" \
            --exclude="quality_check*.py" \
            --exclude="matlab_quality_check.py" .; then
            echo "‚ùå ERROR: Placeholders found in code"
            exit 1
          else
            echo "‚úÖ No placeholders found"
          fi
            
      - name: Check for magic numbers
        id: magic-numbers
        continue-on-error: true  # Non-blocking warning
        run: |
          # Check for common magic numbers that should be constants
          # Exclude quality check scripts and constants_file.py (where constants are defined)
          if grep -r "[^0-9a-zA-Z_]3\.14[0-9]*\|9\.8[0-9]*\|6\.67[0-9]*\|2\.71[0-9]*" \
            --include="*.py" \
            --exclude-dir=".git" \
            --exclude-dir="tests" \
            --exclude="quality_check*.py" \
            --exclude="matlab_quality_check.py" \
            --exclude="constants_file.py" .; then
            echo "‚ö†Ô∏è WARNING: Possible magic numbers found (should be named constants with sources)"
            echo "Examples: 3.14‚Üímath.pi, 9.8‚ÜíGRAVITY_M_S2, 2.71‚Üímath.e"
            exit 1  # Fail to trigger warning indicator in summary
          else
            echo "‚úÖ No obvious magic numbers found"
          fi
          
      - name: Check for approximations
        id: approximations
        run: |
          # Fail if "approximately" or similar found (exclude tests and allow scientific notation)
          # Filter out valid scientific notation patterns:
          # Re~ = Reynolds number, Ma~ = Mach number, Cd~ = Drag coefficient, Cl~ = Lift coefficient
          if grep -ri "approximately\|roughly" \
            --include="*.py" --include="*.m" \
            --exclude-dir=".git" \
            --exclude-dir="docs" \
            --exclude-dir="archive" \
            --exclude-dir="legacy" \
            --exclude-dir="experimental" \
            --exclude-dir="*test*" \
            --exclude-dir="*Test*" . | \
            grep -v "#.*Re~" | \
            grep -v "#.*Ma~" | \
            grep -v "#.*Cd~" | \
            grep -v "#.*Cl~" | \
            grep -v "#.*[A-Z][a-z]*~[0-9]"; then
            echo "‚ùå ERROR: Approximations found - use exact values with sources"
            exit 1
          else
            echo "‚úÖ No approximations found"
          fi
      - name: Lint with Ruff
        id: ruff
        run: |
          echo "üîç Running Ruff linter..."
          if [ -f ruff.toml ]; then
            # ‚úÖ Respect config file, don't override
            ruff check .
          else
            # ‚úÖ Fallback with explicit rules
            ruff check . --select ALL
          fi
          
      - name: Type check with MyPy
        id: mypy
        run: |
          echo "üîç Running MyPy type checker..."
          # Remove any existing mypy cache to avoid serialization errors
          rm -rf .mypy_cache
          # Use read-only cache directory to prevent cache writes and avoid internal errors
          TMP_CACHE=$(mktemp -d)
          chmod 555 "$TMP_CACHE"  # Read-only, prevents cache writes
          trap "rm -rf $TMP_CACHE" EXIT
          # Enable pipefail to capture mypy exit code correctly (not tee's exit code)
          set -o pipefail
          if [ -f mypy.ini ]; then
            mypy . --config-file mypy.ini --no-incremental --cache-dir="$TMP_CACHE" 2>&1 | tee mypy_output.txt || {
              EXIT_CODE=$?
              # Check if it's the internal error we're trying to avoid
              if grep -q "Internal error: unresolved placeholder type None" mypy_output.txt; then
                echo "‚ö†Ô∏è  Mypy internal error detected (cache serialization bug). Checking for real errors..."
                # Re-run without cache to see actual errors
                rm -rf "$TMP_CACHE"
                TMP_CACHE2=$(mktemp -d)
                chmod 555 "$TMP_CACHE2"
                # Run mypy again and capture output, filtering out internal error and success messages
                # Use set -o pipefail to capture mypy exit code correctly
                set -o pipefail
                MYPY_EXIT=0
                mypy . --config-file mypy.ini --no-incremental --cache-dir="$TMP_CACHE2" 2>&1 | grep -vE "(Internal error|Success:|Warning:)" > mypy_filtered.txt || MYPY_EXIT=$?
                set +o pipefail
                rm -rf "$TMP_CACHE2"
                # Check mypy exit code and filtered output for real errors
                # Exit code 0 means success, non-zero means errors
                # Only fail if we have actual errors (not just warnings or empty output)
                if [ "${MYPY_EXIT:-0}" -ne 0 ] && [ -s mypy_filtered.txt ] && grep -qE "error:|Found [0-9]+ error" mypy_filtered.txt; then
                  echo "‚ùå Real type errors found (not just internal error):"
                  cat mypy_filtered.txt
                  rm -f mypy_filtered.txt
                  exit ${MYPY_EXIT}
                else
                  echo "‚úÖ No real type errors found, only internal error"
                  rm -f mypy_filtered.txt
                  exit 0  # Only pass if no real errors
                fi
              else
                rm -rf "$TMP_CACHE"
                exit $EXIT_CODE
              fi
            }
          elif [ -f pyproject.toml ] && grep -qE '^\s*\[tool\.mypy\]' pyproject.toml; then
            mypy . --no-incremental --cache-dir="$TMP_CACHE" 2>&1 | tee mypy_output.txt || {
              EXIT_CODE=$?
              if grep -q "Internal error: unresolved placeholder type None" mypy_output.txt; then
                echo "‚ö†Ô∏è  Mypy internal error detected (cache serialization bug). Checking for real errors..."
                rm -rf "$TMP_CACHE"
                TMP_CACHE2=$(mktemp -d)
                chmod 555 "$TMP_CACHE2"
                set -o pipefail
                mypy . --no-incremental --cache-dir="$TMP_CACHE2" 2>&1 | grep -vE "(Internal error|Success:|Warning:)" > mypy_filtered.txt || MYPY_EXIT=$?
                set +o pipefail
                rm -rf "$TMP_CACHE2"
                # Check mypy exit code and filtered output for real errors
                # Only fail if we have actual errors (not just warnings or empty output)
                if [ "${MYPY_EXIT:-0}" -ne 0 ] && [ -s mypy_filtered.txt ] && grep -qE "error:|Found [0-9]+ error" mypy_filtered.txt; then
                  echo "‚ùå Real type errors found (not just internal error):"
                  cat mypy_filtered.txt
                  rm -f mypy_filtered.txt
                  exit ${MYPY_EXIT}
                else
                  echo "‚úÖ No real type errors found, only internal error"
                  rm -f mypy_filtered.txt
                  exit 0
                fi
              else
                rm -rf "$TMP_CACHE"
                exit $EXIT_CODE
              fi
            }
          else
            # ‚úÖ Non-strict fallback to avoid conflicts
            mypy . --ignore-missing-imports --no-incremental --cache-dir="$TMP_CACHE" 2>&1 | tee mypy_output.txt || {
              EXIT_CODE=$?
              if grep -q "Internal error: unresolved placeholder type None" mypy_output.txt; then
                echo "‚ö†Ô∏è  Mypy internal error detected (cache serialization bug). Checking for real errors..."
                rm -rf "$TMP_CACHE"
                TMP_CACHE2=$(mktemp -d)
                chmod 555 "$TMP_CACHE2"
                set -o pipefail
                mypy . --ignore-missing-imports --no-incremental --cache-dir="$TMP_CACHE2" 2>&1 | grep -vE "(Internal error|Success:|Warning:)" > mypy_filtered.txt || MYPY_EXIT=$?
                set +o pipefail
                rm -rf "$TMP_CACHE2"
                # Check mypy exit code and filtered output for real errors
                # Only fail if we have actual errors (not just warnings or empty output)
                if [ "${MYPY_EXIT:-0}" -ne 0 ] && [ -s mypy_filtered.txt ] && grep -qE "error:|Found [0-9]+ error" mypy_filtered.txt; then
                  echo "‚ùå Real type errors found (not just internal error):"
                  cat mypy_filtered.txt
                  rm -f mypy_filtered.txt
                  exit ${MYPY_EXIT}
                else
                  echo "‚úÖ No real type errors found, only internal error"
                  rm -f mypy_filtered.txt
                  exit 0
                fi
              else
                rm -rf "$TMP_CACHE"
                exit $EXIT_CODE
              fi
            }
          fi
          rm -rf "$TMP_CACHE"
          
      - name: Format check with Black
        id: black
        run: |
          echo "üîç Checking code formatting with Black..."
          # ‚úÖ Check source directories explicitly
          if [ -d python/src ]; then
            if [ -d python/tests ]; then
              black --check --diff python/src python/tests
            else
              black --check --diff python/src
            fi
          elif [ -d python ]; then
            black --check --diff python
          elif [ -d src ]; then
            if [ -d tests ]; then
              black --check --diff src tests
            else
              black --check --diff src
            fi
          else
            black --check --diff .
          fi
          
      - name: Run pre-commit
        id: pre-commit
        continue-on-error: true  # Non-blocking to match other repos
        run: |
          pre-commit run --all-files --show-diff-on-failure
          PRECOMMIT_EXIT_CODE=$?
          if [ $PRECOMMIT_EXIT_CODE -ne 0 ]; then
            echo "‚ö†Ô∏è Pre-commit checks failed, but this does not block CI. Please fix these issues."
          fi
          
      - name: Run tests with coverage
        id: tests
        run: |
          echo "üß™ Running tests..."
          # ‚úÖ Detect source directory for accurate coverage
          if [ -d python/src ]; then
            COV_TARGET="python/src"
          elif [ -d python ]; then
            COV_TARGET="python"
          elif [ -d src ]; then
            COV_TARGET="src"
          else
            COV_TARGET="."
          fi

          if [ -f pytest.ini ]; then
            pytest --cov="$COV_TARGET" --cov-report=xml --cov-report=term-missing
          elif [ -d python/tests ]; then
            cd python
            if [ -d src ]; then
              pytest tests/ --cov=src --cov-report=xml --cov-report=term-missing
              EXIT_CODE=$?
            else
              pytest tests/ --cov=. --cov-report=xml --cov-report=term-missing
              EXIT_CODE=$?
            fi
            cd ..
            exit $EXIT_CODE
          elif [ -d tests ]; then
            pytest tests/ --cov="$COV_TARGET" --cov-report=xml --cov-report=term-missing
          else
            echo "‚ö†Ô∏è No tests directory found, skipping tests"
          fi
          
      - name: Check for coverage file
        id: coverage-check
        run: |
          # ‚úÖ Check for coverage.xml anywhere in the repository (matches upload pattern)
          if find . -name 'coverage.xml' -type f | grep -q .; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Upload coverage to Codecov
        if: steps.coverage-check.outputs.exists == 'true'
        uses: codecov/codecov-action@v4
        with:
          # ‚úÖ Wildcard pattern for flexibility
          files: '**/coverage.xml'
          flags: unittests
          name: codecov-umbrella
          fail_ci_if_error: false
          # ‚úÖ Always include token
          token: ${{ secrets.CODECOV_TOKEN }}
          
      - name: Verify reproducibility
        run: |
          # Check that random seeds are set in Python files using randomness
          echo "Checking for unseeded randomness..."
          for file in $(find . -name "*.py" -type f -not -path "./archive/*" -not -path "./legacy/*"); do
            if grep -q "np\.random\|random\.\|torch\." "$file" 2>/dev/null; then
              if ! grep -q "seed\|random_state\|generator" "$file"; then
                echo "‚ö†Ô∏è Warning: $file uses randomness without visible seed"
              fi
            fi
          done
          
      - name: Check for required constants documentation
        run: |
          # Verify physical constants have units and sources
          echo "Checking constants documentation..."
          for file in $(find . -name "*.py" -type f -not -path "./tests/*" -not -path "./archive/*"); do
            if grep -q "GRAVITY\|MASS\|DENSITY\|COEFFICIENT" "$file" 2>/dev/null; then
              if ! grep -q "\[.*\].*#\|#.*\[.*\]" "$file"; then
                echo "‚ö†Ô∏è Warning: $file may have undocumented constants (need units + source)"
              fi
            fi
          done
          
      - name: Summary
        if: always()
        run: |
          echo "### CI Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Check | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          
          # MATLAB Quality Check (non-blocking, continue-on-error: true)
          if [ "${{ steps.matlab-quality.outcome }}" == "success" ]; then
            echo "| MATLAB Quality Check | ‚úÖ |" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.matlab-quality.outcome }}" == "skipped" ]; then
            echo "| MATLAB Quality Check | ‚è≠Ô∏è (skipped) |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| MATLAB Quality Check | ‚ö†Ô∏è (non-blocking) |" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Quality Check
          if [ "${{ steps.quality-check.outcome }}" == "success" ]; then
            echo "| Quality Check | ‚úÖ |" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.quality-check.outcome }}" == "skipped" ]; then
            echo "| Quality Check | ‚è≠Ô∏è (skipped) |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Quality Check | ‚ùå |" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Placeholders
          if [ "${{ steps.placeholders.outcome }}" == "success" ]; then
            echo "| No Placeholders | ‚úÖ |" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.placeholders.outcome }}" == "skipped" ]; then
            echo "| No Placeholders | ‚è≠Ô∏è (skipped) |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| No Placeholders | ‚ùå |" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Magic Numbers
          if [ "${{ steps.magic-numbers.outcome }}" == "success" ]; then
            echo "| No Magic Numbers | ‚úÖ |" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.magic-numbers.outcome }}" == "skipped" ]; then
            echo "| No Magic Numbers | ‚è≠Ô∏è (skipped) |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| No Magic Numbers | ‚ö†Ô∏è |" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Approximations
          if [ "${{ steps.approximations.outcome }}" == "success" ]; then
            echo "| No Approximations | ‚úÖ |" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.approximations.outcome }}" == "skipped" ]; then
            echo "| No Approximations | ‚è≠Ô∏è (skipped) |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| No Approximations | ‚ùå |" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Ruff
          if [ "${{ steps.ruff.outcome }}" == "success" ]; then
            echo "| Ruff Linting | ‚úÖ |" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.ruff.outcome }}" == "skipped" ]; then
            echo "| Ruff Linting | ‚è≠Ô∏è (skipped) |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Ruff Linting | ‚ùå |" >> $GITHUB_STEP_SUMMARY
          fi
          
          # MyPy
          if [ "${{ steps.mypy.outcome }}" == "success" ]; then
            echo "| MyPy Type Checking | ‚úÖ |" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.mypy.outcome }}" == "skipped" ]; then
            echo "| MyPy Type Checking | ‚è≠Ô∏è (skipped) |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| MyPy Type Checking | ‚ùå |" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Black
          if [ "${{ steps.black.outcome }}" == "success" ]; then
            echo "| Black Formatting | ‚úÖ |" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.black.outcome }}" == "skipped" ]; then
            echo "| Black Formatting | ‚è≠Ô∏è (skipped) |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Black Formatting | ‚ùå |" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Pre-commit (non-blocking)
          if [ "${{ steps.pre-commit.outcome }}" == "success" ]; then
            echo "| Pre-commit | ‚úÖ |" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.pre-commit.outcome }}" == "skipped" ]; then
            echo "| Pre-commit | ‚è≠Ô∏è (skipped) |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Pre-commit | ‚ö†Ô∏è (non-blocking) |" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Tests
          if [ "${{ steps.tests.outcome }}" == "success" ]; then
            echo "| Tests + Coverage | ‚úÖ |" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.tests.outcome }}" == "skipped" ]; then
            echo "| Tests + Coverage | ‚è≠Ô∏è (skipped) |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Tests + Coverage | ‚ùå |" >> $GITHUB_STEP_SUMMARY
          fi

  security-check:
    name: Security Check
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    # ‚úÖ Always set up Python
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Run Bandit security check
      # ‚úÖ Use continue-on-error instead of || true
      continue-on-error: true
      run: |
        pip install bandit==1.7.7
        # ‚úÖ Exclude test directories, target source code only
        # Note: Bandit exclusion paths are relative to the current working directory (repo root)
        if [ -d python/src ]; then
          bandit -r python/src -x python/tests -f json -o bandit-report.json
        elif [ -d python ]; then
          bandit -r python -x python/tests -f json -o bandit-report.json
        elif [ -d src ]; then
          bandit -r src -x tests -f json -o bandit-report.json
        else
          bandit -r . -x tests -f json -o bandit-report.json
        fi

    - name: Upload Bandit results
      uses: actions/upload-artifact@v4
      with:
        name: bandit-report
        path: bandit-report.json
        # ‚úÖ Handle missing files gracefully
        if-no-files-found: ignore

  documentation-check:
    name: Documentation Check
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    # ‚úÖ Always set up Python
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Check documentation links
      run: |
        echo "üìö Checking documentation..."
        if [ -f README.md ]; then
          echo "‚úÖ README.md found"
        else
          echo "‚ö†Ô∏è No README.md found"
        fi

    - name: Check for docstrings
      # ‚úÖ Use continue-on-error instead of || echo
      continue-on-error: true
      run: |
        echo "üìù Checking for docstrings..."
        pip install pydocstyle==6.3.0
        # ‚úÖ Check source directories only
        if [ -d python/src ]; then
          pydocstyle python/src
        elif [ -d python ]; then
          pydocstyle python
        elif [ -d src ]; then
          pydocstyle src
        else
          pydocstyle .
        fi

